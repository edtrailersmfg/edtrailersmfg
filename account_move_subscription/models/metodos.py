# -*- coding: utf-8 -*-
##############################################################################
#
#   Original by Odoo SA
#   Forked by:
#   2016 - Argil Consulting SA de CV
#    (<http://www.argil.mx>)
##############################################################################

from odoo import api, fields, models, _
from odoo.exceptions import UserError
from datetime import datetime
from dateutil.relativedelta import relativedelta
import time
# ---------------------------------------------------------
# Account Entries Models
# ---------------------------------------------------------

class account_model(models.Model):
    _inherit = "account.model"

    
    def _get_line_info(self, line, date_maturity):
        context = dict(self._context or {})
        return {
            #'journal_id'    : journal.id,
            'analytic_account_id' : line.analytic_account_id.id,
            'name'          : line.name,
            'quantity'      : line.quantity,
            'debit'         : line.debit,
            'credit'        : line.credit,
            'account_id'    : line.account_id.id,
            'partner_id'    : line.partner_id.id,
            'date'          : context.get('date', fields.Date.context_today(self)),
            'date_maturity' : context.get('date', fields.Date.context_today(self)),
        }

    
    def generate(self, data=None):
        if data is None:
            data = {}
        move_ids = []
        entry = {}
        account_move_obj = self.env['account.move']
        pt_obj = self.env['account.payment.term']
        period_obj = self.env['account.period']

        context = dict(self._context or {})

        if data.get('date', False):
            context = dict(context)
            context.update({'date' : data['date']})

        move_date = context.get('date', fields.Date.context_today(self))
        #move_date = datetime.strptime(move_date,"%Y-%m-%d")        
        for model in self:
            move_vals = {}
            ctx = context.copy()
            ctx.update({'company_id' : model.company_id.id})
            period_ids = period_obj.with_context(ctx).find(dt=context.get('date', False))
            period_id = period_ids and period_ids[0].id or False
            ctx.update({'journal_id' : model.journal_id.id, 'period_id' : period_id})
            try:
                entry['name'] = model.name%{'year' : move_date.strftime('%Y'), 'month' : move_date.strftime('%m'), 'date' : move_date.strftime('%Y-%m')}
            except:
                raise UserError(_('Wrong Model!'), _('You have a wrong expression in your model!'))            
            
            account_move = {'ref'               : entry['name'],
                            'item_concept'      : entry['name'],
                            'journal_id'        : model.journal_id.id,
                            'narration'         : model.notes,
                            'date'              : context.get('date', fields.Date.context_today(self))
                            }
            account_move_lines = []
            
            for line in model.lines_id:
                date_maturity = context.get('date',time.strftime('%Y-%m-%d'))
                if line.date_maturity == 'partner':
                    if not line.partner_id:
                        raise UserError(_("Error!\n\nMaturity date of entry line generated by model line '%s' of model '%s' is based on partner payment term!" \
                                                                "\nPlease define partner on it!")%(line.name, model.name))

                    payment_term_id = line.partner_id and (model.journal_id.move_type == 'purchase' and \
                                        line.partner_id.property_supplier_payment_term_id or
                                        line.partner_id.property_payment_term_id) or False
                    if payment_term_id:
                        pterm_list = payment_term_id.compute(value=1, date_ref=date_maturity)
                        if pterm_list:
                            pterm_list = [l[0] for l in pterm_list]
                            pterm_list.sort()
                            date_maturity = pterm_list[-1]

                val = (0,0, self.with_context(context)._get_line_info(line, date_maturity))
                
                account_move_lines.append(val)
            account_move.update({'line_ids' : account_move_lines})
            move_id = account_move_obj.create(account_move)
            move_ids.append(move_id)
        return move_ids

    @api.onchange('journal_id')
    def _onchange_journal_id(self):
        company_id = self.journal_id.company_id.id


# ---------------------------------------------------------
# Account Subscription
# ---------------------------------------------------------


class account_subscription(models.Model):
    _inherit = "account.subscription"
    
    def state_draft(self):
        self.write({'state' :'draft'})
        return False

    def check(self):
        todone = self.env['account.subscription']
        for sub in self:
            ok = True
            for line in sub.lines_id:
                if not line.move_id.id:
                    ok = False
                    break
            if ok:
                todone += sub
        if todone:
            todone.write({'state' : 'done'})
        return False

    def remove_line(self):
        toremove = self.env['account.subscription.line']
        for sub in self:
            for line in sub.lines_id:
                if not line.move_id.id:
                    toremove += line
        if toremove:
            toremove.unlink()
        self.write({'state' : 'draft'})
        return False

    def compute(self):
        sub_line_obj = self.env['account.subscription.line']
        for sub in self:
            ds = sub.date_start
            for i in range(sub.period_total):
                sub_line_obj.create({'date' : ds, 'subscription_id' : sub.id})
                if sub.period_type=='day':
                    ds = ds + relativedelta(days=sub.period_nbr)
                if sub.period_type=='month':
                    ds = ds + relativedelta(months=sub.period_nbr)
                if sub.period_type=='year':
                    ds = ds + relativedelta(years=sub.period_nbr)
        self.write({'state' :'running'})
        return True


class account_subscription_line(models.Model):
    _inherit = "account.subscription.line"
    
    def move_create(self):
        tocheck = self.env['account.subscription']
        all_moves = []
        obj_model = self.env['account.model']
        
        for line in self:
            data = {'date' : line.date}
            move_ids = line.subscription_id.model_id.generate(data)
            tocheck += line.subscription_id
            line.write({'move_id' : move_ids[0].id})
            all_moves.extend(move_ids)
        if tocheck:
            tocheck.check()
        return all_moves



# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:    